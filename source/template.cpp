#define PROFILER_ENABLED 1
#define MICRO_PROFILER_ENABLED 1
#include "test1.h"
#include "tileset.h"
#include <string.h>
#include "gba.h"
#include "fixmath.h"
#include "ECS.h"
#include "mgba.h"
#include "profiler.h"
#define u8 uint8
#define u32 uint32
#include "bg1_bin.h"
#undef u8
#undef u32

// NOTE: Max rom size (3.355*10^7)

// FIXME: Remove ControllerComponent and use FlagsComponent with a CONTROLLER flag instead

// http://ianfinlayson.net/class/cpsc305/
//
// idea: circular buffer for collision detection
// example: limit 3, 5 objects
// frame 1: 0, 1, 2
// frame 2: 1, 2, 3
// frame 3: 2, 3, 4
// frame 4: 3, 4, 0
// frame 5: 4, 0, 1
// could also have two priorities, one for fast moving (that is always checked) and one for slow (checked using above hack).
//
// collision detection against environment:
// https://pineight.com/mw/index.php?title=Four-corner_collision_detection but with more points tested
// sample along the perimiter, evenly divided in the smallest number of points while the distance between sampling points are smaller than the size of a tile.
// Response becomes a bit more complicated since we cant really use the objects center to determen case 1,2,4,8
// so that case should prob be solved by finding the edge closest to the embedded corner and filling in the opposit one.
// Atleast when the largest side of the object is 2 a hit in the middle point could be counted as a hit in the neighboring corners:
// ...    ..#
// ..# -> ..#
// ...
// this means we can use the same fast 8bit representation of collisions.
// A good limitation might actually be to have the max size of objects that can collide with the environment be 2*tileSize x 2*tileSize
// larger objects will have to either fake collision or just ignore the environment.

// Environment not loaded:
// tile set to use: Generated by the tile editor?
// entity generators for entities in scene. An array of function pointers taking a tile position: Generated by the tile editor
// tile type: empty, filled, slope left, slope right, entity (always empty)
//   need 5 bits
// if not entity:
//   graphics tile: how many possible tile variations?
// if entity:
//   entity generator index: index into the entity generator array
//
// This will then be expanded to a more usefull but larger format where we have the collision info, entities are created using the
// enitity generator functions etc.

// Audio, probably use maxmod

// Flashcart order id: OYSUWQOXI

// Background: Backgrounds are [32|64]x[32|64], ie max 2x2 screens. Since we prob. want more than that
// we might do something like use two bg's where one is offset by 64*8 in x or y, giving us 4x2 or 2x4
// screens max. Or we could load as much as possible into vmem and swap BG_TILEMAP to change where they
// point...
// NOTE: This is wrong, if we use VIDEO_MODE_1 or VIDEO_MODE_2 we get affine backgrounds that can be 128x128, ie 4x4
// TODO: Investigate how affine matrices work, just switching to VIDEO_MODE_1 does not work...
// Ah! They use a different mapping scheme...

// NOTE: We either need to sort sprites on priority, or make sure that backgrounds only have lowest or highest priority!

// NOTE: Palettes:
// Sprites: Player = 0
//          Bullets(?) = 1
//          Enemies = 2-16
// Background: ?

#if 0
typedef uint32 (*Spawner)(uint8 x, uint8 y);
struct Scene {
    uint16 bg0[32*32];
    uint16 bg1[30*6*20*6];
    uint16 bg2[30*6*20*6];
    uint16 bg3[30*6*20*6];
    // 0 = empty, 1 = filled, 2 = slope up right, 3 = slope up left, x >= 4 = spawner for x-4 in spawners array
    uint8 other[30*6*20*6];
    Spawner spawners[252];
    uint8 posX, posY, sizeX, sizeY;
};

Scene *currentScene;
const Scene scenes[100][100];
#endif

void uploadPalletteMemory(const uint16 *palette, PaletteBank *paletteBank) {
    REG_DMA[3].src = palette;
    REG_DMA[3].dst = paletteBank;
    REG_DMA[3].count = 16;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_16 | DMA_ENABLE;
}

void uploadTileMemory() {
    REG_DMA[3].src = test1Tiles;
    REG_DMA[3].dst = &MEM_TILE[4][1];
    REG_DMA[3].count = test1TilesLen/4;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_32 | DMA_ENABLE;
    REG_DMA[3].src = tilesetTiles;
    REG_DMA[3].dst = &MEM_TILE[0][0];
    REG_DMA[3].count = tilesetTilesLen/4;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_32 | DMA_ENABLE;
}

void updateSpritePosition(SpriteComponent *sprite, PositionComponent *pos) {
    int32 xScreenPos = (fix24b8ToInt(pos->p.x) + sprite->relX);
    int32 yScreenPos = (fix24b8ToInt(pos->p.y) + sprite->relY);
    if (xScreenPos + sprite->sizeX >= 0 && yScreenPos + sprite->sizeY >= 0 &&
        xScreenPos < 240 && yScreenPos < 160) {
        enable(sprite->sprite);
        setSpritePos(sprite->sprite, xScreenPos & 0x1FF, yScreenPos & 0x1FF);
    } else {
        disable(sprite->sprite);
    }
}

void updatePosition(PositionComponent *pos) {
    pos->p = pos->p + pos->dp;
}

void updateControllerDp(PositionComponent *pos, ControllerComponent *dummy) {
    V2fix24b8 ddp = v2fix24b8(getKeyState(KEY_LEFT) * -1.0f + getKeyState(KEY_RIGHT),
                              getKeyState(KEY_UP) * -1.0f + getKeyState(KEY_DOWN));
    pos->dp = pos->dp + normalize(ddp) * fix24b8(0.1f);
}

// 3737 cycles to dma into vram, ie ~1.33% of refresh. 0.2% of ROM
const uint16 virtualTileMap[20*6][30*6] = {{MAP_ENTRY_PALBANK(1) | 0, MAP_ENTRY_PALBANK(1) | 1, MAP_ENTRY_PALBANK(1) | 2, MAP_ENTRY_PALBANK(1) | 3}, {MAP_ENTRY_PALBANK(1) | 40, MAP_ENTRY_PALBANK(1) | 41, MAP_ENTRY_PALBANK(1) | 42, MAP_ENTRY_PALBANK(1) | 43}};

int main() {
    mgba_open();
    initECS();
    initProfiler();
    uploadPalletteMemory(test1Pal, &MEM_SPRITE_PALETTE[0]);
    uploadPalletteMemory(tilesetPal, &MEM_BG_PALETTE[1]);
    uploadTileMemory();

    volatile ObjectAttributes *spriteAttribs = &MEM_OAM[0];

    setSpriteSize16x16(spriteAttribs);
    setSprite4bpp(spriteAttribs);
    spriteAttribs->attr2 = 1;      // Start at the first tile in tile

    setSpritePos(spriteAttribs, 30, 150);

    REG_BG2_CONTROLLER = BG_TILEBLOCK(0) | BG_TILEMAP(28) | BG_REGULAR_32x32 | BG_4BPP;
    REG_BG2_AFFINE_X_OFFSET= 0;
    REG_BG2_AFFINE_Y_OFFSET= 0;


    REG_DISPLAY_CONTROLLER = VIDEO_MODE_0 | ENABLE_OBJECTS | MAPPINGMODE_1D | ENABLE_BG2;

    uint32 player = newEntity();

    PositionComponent *playerPos = addComponent<PositionComponent>(player);

    playerPos->dp = v2fix24b8(0, 0);
    playerPos->p = v2fix24b8(16, 16);

    SpriteComponent *playerSprite = addComponent<SpriteComponent>(player);
    playerSprite->sprite = spriteAttribs;
    playerSprite->relX = -8;
    playerSprite->relY = -8;
    playerSprite->sizeX = 16;
    playerSprite->sizeY = 16;

    addComponent<ControllerComponent>(player);



    while (1) {
        vsync();
        MICRO_PROFILE_START();
        REG_DMA[3].controller = 0;
        REG_DMA[3].count = 30;
        for (int i = 0; i < 20; ++i) {
            REG_DMA[3].dst = &MEM_MAP[28][i*32];
            REG_DMA[3].src = &bg1_bin[i*30*2];
            REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_16 | DMA_ENABLE;
        }
        MICRO_PROFILE_STOP("DMA");
        mgba_printf(MGBA_LOG_DEBUG, "%u", bg1_bin_size);
        //PROFILE("main loop");
        {
            //PROFILE("update controller");
            systemRun<PositionComponent, ControllerComponent>(updateControllerDp);
        }
        {
            //PROFILE("update position");
            systemRun<PositionComponent>(updatePosition);
        }
        {
            //PROFILE("update sprite position");
            systemRun<SpriteComponent, PositionComponent>(updateSpritePosition);
        }
    }
}