#define PROFILER_ENABLED 1
#define MICRO_PROFILER_ENABLED 1
#define COLLISION_LOG 1
#define LIKELY(x) __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#include "test1.h"
#include "tilesets.h"
#include <string.h>
#include "gba.h"
#include "fixmath.h"
#include "ECS.h"
#include "mgba.h"
#include "profiler.h"
#include "ai.h"
#include "collision.h"
struct Room {
    const uint8 x, y, sizeX, sizeY;
    const uint16 *bg1;
    const uint8 *collisionLayer;
};
#define u8 uint8
#define u32 uint32
#include "rooms.h"
#undef u8
#undef u32
// NOTE: Max rom size (3.355*10^7)

// TODO: Use attributes hot and cold, LIKELY and UNLIKELY etc

// FIXME: Remove ControllerComponent and use FlagsComponent with a CONTROLLER flag instead

// NOTE: Use BIOS compression for all images!

// http://ianfinlayson.net/class/cpsc305/
//
// idea: circular buffer for collision detection
// example: limit 3, 5 objects
// frame 1: 0, 1, 2
// frame 2: 1, 2, 3
// frame 3: 2, 3, 4
// frame 4: 3, 4, 0
// frame 5: 4, 0, 1
// could also have two priorities, one for fast moving (that is always checked) and one for slow (checked using above hack).
//
// collision detection against environment:
// https://pineight.com/mw/index.php?title=Four-corner_collision_detection but with more points tested
// sample along the perimiter, evenly divided in the smallest number of points while the distance between sampling points are smaller than the size of a tile.
// Response becomes a bit more complicated since we cant really use the objects center to determen case 1,2,4,8
// so that case should prob be solved by finding the edge closest to the embedded corner and filling in the opposit one.
// Atleast when the largest side of the object is 2 a hit in the middle point could be counted as a hit in the neighboring corners:
// ...    ..#
// ..# -> ..#
// ...
// this means we can use the same fast 8bit representation of collisions.
// A good limitation might actually be to have the max size of objects that can collide with the environment be 2*tileSize x 2*tileSize
// larger objects will have to either fake collision or just ignore the environment.

// Environment not loaded:
// tile set to use: Generated by the tile editor?
// entity generators for entities in scene. An array of function pointers taking a tile position: Generated by the tile editor
// tile type: empty, filled, slope left, slope right, entity (always empty)
//   need 5 bits
// if not entity:
//   graphics tile: how many possible tile variations?
// if entity:
//   entity generator index: index into the entity generator array
//
// This will then be expanded to a more usefull but larger format where we have the collision info, entities are created using the
// enitity generator functions etc.

// Audio, probably use maxmod

// Flashcart order id: OYSUWQOXI

// Background: Backgrounds are [32|64]x[32|64], ie max 2x2 screens. Since we prob. want more than that
// we might do something like use two bg's where one is offset by 64*8 in x or y, giving us 4x2 or 2x4
// screens max. Or we could load as much as possible into vmem and swap BG_TILEMAP to change where they
// point...

// NOTE: Copying backgrounds take 13544 cycles ie 4.82% of refresh or 16.17% of vblank

// NOTE: We either need to sort sprites on priority, or make sure that backgrounds only have lowest or highest priority!

// NOTE: Palettes:
// Sprites: Player = 0
//          Bullets(?) = 1
//          Enemies = 2-16
// Background: ?

static inline
void clearDeadComponents() {
    while (killedEntitiesHead) {
        clearDeadComponents<SpriteComponent>(killedEntities[killedEntitiesHead]);
        clearDeadComponents<PositionComponent>(killedEntities[killedEntitiesHead]);
        clearDeadComponents<ControllerComponent>(killedEntities[killedEntitiesHead]);
        clearDeadComponents<FlagsComponent>(killedEntities[killedEntitiesHead]);
        clearDeadComponents<AIComponent>(killedEntities[killedEntitiesHead]);
        clearDeadComponents<TileCollisionComponent>(killedEntities[killedEntitiesHead]);
        pushDeadEntity(killedEntities[killedEntitiesHead]);
        killedEntitiesHead--;
    }
}

#if 0
typedef uint32 (*Spawner)(uint8 x, uint8 y);
struct Scene {
    uint16 bg0[32*32];
    uint16 bg1[30*6*20*6];
    uint16 bg2[30*6*20*6];
    uint16 bg3[30*6*20*6];
    // 0 = empty, 1 = filled, 2 = slope up right, 3 = slope up left, x >= 4 = spawner for x-4 in spawners array
    uint8 other[30*6*20*6];
    Spawner spawners[252];
    uint8 posX, posY, sizeX, sizeY;
};

uint32 spawnerJumper(uint8 tileX, uint8 tileY) {
    uint32 jumper = newEntity();
    PositionComponent *position = addComponent<PositionComponent>();
    position->p.x = tileX*16;
    position->p.y = tileY*16;
    SpriteComponent *sprite
    return jumper;
}


void foobarSpawner(a...) {
    ...;
    addAINode(ai, TIMER, compose<xImpulseTowardsPlayer<1.11f>, yImpulse<1.11f> >);
    ...;
}

// TODO: How the f**k to support recursive stuff?
//       maybe store fsm states in const arrays and make this take a pointer to the fsmArray as well as an index?
//       that would also allow for updating multiple nodes... Might need some way to make node groups so we can update partially or something like that...
//       Maybe have an uint8 groupTop in AIComponent, and uint8 group in AINode, default to group 0,
//       have uint8 newAIGroup(AIComponent *), void addAINodeGroup(AIComponent *, AIEventType, AINodeFunc...) and a
//       removeAINodesInGroup(AIComponent *, uint8)
//       Maybe write some kind of FSM editor that generates these arrays...
//       We then have
struct FSMNode {
    AIEventType triggerEvent;
    AINodeFunc run;
};

const FSMNode bossFSM[][] = {{{TIMER, changeFSM<group, 1>, other stuff to do here}}, {{TIMER, changeFSM<group, 0>}, more stuff}};

template<AIEventType triggerEvent, AINodeFunc nextState>
void fsm(AIComponent *ai, PositionComponent *position,
         SpriteComponent *sprite, uint32 entity) {
    for (AINode *node = ai->nodes; node; node = node->next) {
        if (node->triggerEvent == triggerEvent) { // FIXME: should only update the fsm node(?)
            node->run = nextState;
            break;
        }
    }
}

#endif

void uploadPalletteMemory(const uint16 *palette, PaletteBank *paletteBank) {
    REG_DMA[3].src = palette;
    REG_DMA[3].dst = paletteBank;
    REG_DMA[3].count = 16;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_16 | DMA_ENABLE;
}

void uploadTileMemory() {
    REG_DMA[3].src = test1Tiles;
    REG_DMA[3].dst = &MEM_TILE[4][1];
    REG_DMA[3].count = test1TilesLen/4;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_32 | DMA_ENABLE;
    REG_DMA[3].src = tilesetsTiles;
    REG_DMA[3].dst = &MEM_TILE[0][0];
    REG_DMA[3].count = tilesetsTilesLen/4;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_32 | DMA_ENABLE;
}

int16 cameraOffsetX = 0;
int16 cameraOffsetY = 0;

void updateSpritePosition(SpriteComponent *sprite, PositionComponent *pos) {
    int32 worldSpritePosX = (fix24b8ToInt(pos->p.x) + sprite->relX);
    int32 worldSpritePosY = (fix24b8ToInt(pos->p.y) + sprite->relY);
    int32 screenSpritePosX = worldSpritePosX - cameraOffsetX;
    int32 screenSpritePosY = worldSpritePosY - cameraOffsetY;
    if (screenSpritePosX + sprite->sizeX >= 0 && screenSpritePosY + sprite->sizeY >= 0 &&
        screenSpritePosX < 240 && screenSpritePosY < 160) {
        enable(sprite->sprite);
        setSpritePos(sprite->sprite, screenSpritePosX & 0x1FF, screenSpritePosY & 0x1FF);
    } else {
        disable(sprite->sprite);
    }
}

void updatePosition(PositionComponent *pos) {
    pos->p = pos->p + pos->dp;
}

void updateControllerDp(PositionComponent *pos, ControllerComponent *dummy, FlagsComponent *flags) {
    pos->dp.x += fix24b8(getKeyState(KEY_LEFT) * -0.125f + getKeyState(KEY_RIGHT) * 0.125f);
    if (isSet(&flags->flags, ON_GROUND)) {
        pos->dp.y = -fix24b8(getKeyPressed(KEY_UP) * 6.0f);
    }
}

void gravitySystem(PositionComponent *pos, GravityComponent *gravity) {
    pos->dp.y += gravity->value;
}

void frictionSystem(PositionComponent *pos, FrictionComponent *friction) {
    pos->dp.x = mul(pos->dp.x, friction->value.x);
    pos->dp.y = mul(pos->dp.y, friction->value.y);
}

uint8 cartRamBuffer[512];

__attribute__((section(".wram")))
uint8 *readCartRam(uint16 location, int16 size) {
    volatile uint8 *src = &MEM_CART_RAM[location];
    uint8 *dst = cartRamBuffer;
    for (;size;--size) {
        *dst++=*src++;
    }
    return cartRamBuffer;
}

__attribute__((section(".wram")))
uint8 readCartRam(uint16 location) {
    return MEM_CART_RAM[location];
}

const Room *currentRoom;

static inline
void setCollisionMap() {
    collisionMapSizeX = currentRoom->sizeX;
    collisionMapSizeY = currentRoom->sizeY;
    REG_DMA[3].controller = 0;
    REG_DMA[3].count = (currentRoom->sizeX * currentRoom->sizeY)/2;
    REG_DMA[3].dst = collisionMap;
    REG_DMA[3].src = currentRoom->collisionLayer;
    REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_16 | DMA_ENABLE;

}

int main() {
    mgba_open();
    initProfiler();
    uploadPalletteMemory(test1Pal, &MEM_SPRITE_PALETTE[0]);
    uploadPalletteMemory(tilesetsPal, &MEM_BG_PALETTE[1]);
    uploadTileMemory();
    initKeyState();
    currentRoom = rooms + roomMap[0][0];
    setCollisionMap();

    volatile ObjectAttributes *spriteAttribs = &MEM_OAM[0];

    setSpriteSize16x32(spriteAttribs);
    setSprite4bpp(spriteAttribs);
    spriteAttribs->attr2 = 1;      // Start at the first tile in tile

    setSpritePos(spriteAttribs, 30, 150);

    REG_BG1_CONTROLLER = BG_TILEBLOCK(0) | BG_TILEMAP(28) | BG_REGULAR_32x32 | BG_4BPP;


    REG_DISPLAY_CONTROLLER = VIDEO_MODE_0 | ENABLE_OBJECTS | MAPPINGMODE_1D | ENABLE_BG1;

    uint32 player = newEntity();

    PositionComponent *playerPos = addComponent<PositionComponent>(player);

    playerPos->dp = v2fix24b8(0, 0);
    playerPos->p = v2fix24b8(64, 64);

    SpriteComponent *playerSprite = addComponent<SpriteComponent>(player);
    playerSprite->sprite = spriteAttribs;
    playerSprite->relX = -8;
    playerSprite->relY = -16;
    playerSprite->sizeX = 16;
    playerSprite->sizeY = 32;

    addComponent<ControllerComponent>(player);


    TileCollisionComponent *tileCollision = addComponent<TileCollisionComponent>(player);
    tileCollision->upperLeft.x = fix24b8(-8);
    tileCollision->upperLeft.y = fix24b8(-16);
    tileCollision->size.x = fix24b8(16);
    tileCollision->size.y = fix24b8(32);

    GravityComponent *gravity = addComponent<GravityComponent>(player);
    gravity->value = fix24b8(0.3f);

    FrictionComponent *friction = addComponent<FrictionComponent>(player);
    friction->value = v2fix24b8(0.95f, 0.99f);

    FlagsComponent *flags = addComponent<FlagsComponent>(player);
    (void)flags;

    while (1) {
        pumpKeyState();
        vsync();
        PROFILE("main loop");
        cameraOffsetX = fix24b8ToInt(playerPos->p.x - fix24b8(120.0f));
        if (cameraOffsetX < 0) {
            cameraOffsetX = 0;
        }
        cameraOffsetY = fix24b8ToInt(playerPos->p.y - fix24b8(80.0f));
        if (cameraOffsetY < 0) {
            cameraOffsetY = 0;
        }
        {
            PROFILE("update sprite position");
            systemRun<SpriteComponent, PositionComponent>(updateSpritePosition);
        }
        MICRO_PROFILE_START();
        REG_BG1_REGULAR_X_OFFSET = cameraOffsetX & 0x7; // ie mod 8
        REG_BG1_REGULAR_Y_OFFSET = cameraOffsetY & 0x7;
        int16 tileOffsetX = cameraOffsetX/8;
        int16 tileOffsetY = cameraOffsetY/8;
        REG_DMA[3].controller = 0;
        REG_DMA[3].count = min(currentRoom->sizeX*2 - tileOffsetX, 31);
        MICRO_PROFILE_STOP("DMA CONSTANT TIME");
        MICRO_PROFILE_START();
        for (int i = 0; i < min(currentRoom->sizeY*2 - tileOffsetY, 21); ++i) {
            REG_DMA[3].dst = &MEM_MAP[28][i*32];
            REG_DMA[3].src = &currentRoom->bg1[tileOffsetX + (tileOffsetY + i)*currentRoom->sizeX*2];
            REG_DMA[3].controller = DMA_DST_INC | DMA_SRC_INC | DMA_AT_NOW | DMA_16 | DMA_ENABLE;
        }
        MICRO_PROFILE_STOP("DMA LAYER");
        {
            PROFILE("update controller");
            systemRun<PositionComponent, ControllerComponent, FlagsComponent>(updateControllerDp);
        }
        {
            PROFILE("gravity position");
            systemRun<PositionComponent, GravityComponent>(gravitySystem);
        }
        {
            PROFILE("friction position");
            systemRun<PositionComponent, FrictionComponent>(frictionSystem);
        }
        {
            PROFILE("update position");
            systemRun<PositionComponent>(updatePosition);
        }
        {
            PROFILE("tile collision");
            systemRun<PositionComponent, TileCollisionComponent, FlagsComponent>(collisionSystem);
        }
    }
}